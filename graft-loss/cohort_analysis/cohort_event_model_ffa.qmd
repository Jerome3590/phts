---
title: "Event Classification Models by Cohort"
author: "R. Jerome Dixon"
date: "`r format(Sys.Date(), '%B %d, %Y')`"
format:
  html:
    toc: true
    toc-depth: 6
    code-fold: true
    code-summary: "Show the code"
    embed-resources: true
    default-image-extension: svg
    dpi: 600
editor: 
  markdown: 
    wrap: 72
---

## Overview

This analysis examines predictive models for pediatric heart transplant
outcomes by comparing two distinct patient cohorts: Congenital Heart
Disease (CHD) and Myocarditis/Cardiomyopathy. We implement cohort-specific
CatBoost classification models to provide comprehensive risk assessment
and identify cohort-specific predictive factors for event classification.

Modeling Approach:

We train cohort-specific CatBoost classification models:

-   Method: Gradient boosting with binary cross-entropy loss
-   Strengths: robust categorical handling, non-linear interactions, calibrated probabilities


### Formal Feature Analysis (FFA) workflow

-   Train cohort-specific CatBoost models on unified train/test splits.
-   Save each trained model to JSON and export its test split to CSV.
-   Run the Python FFA pipeline (in `ffa_analysis/`) against each saved JSON
    and test dataset to compute AXP-based explanations, feature metrics,
    stability/coverage/reliability validation, permutation significance, and
    comparisons with CatBoost native importance.
-   Export metrics (parquet/json) and visualizations to `ffa_outputs/<cohort>/`.

### Data Loading

```{r echo=FALSE, warning=FALSE, message=FALSE}

library(readr)
library(dplyr)
library(caret)
library(tidyverse)
library(tibble)
library(DT)
library(catboost)
library(here)
library(reticulate)

set.seed(1997)

source("helpers.R")

```

### Model Data

```{r echo=FALSE, warning=FALSE, message=FALSE, eval=FALSE}

# Load the preprocessed model data
model_data <- read_csv("preprocessed_model_data.csv", show_col_types = FALSE)

# Display basic information about the dataset
cat("=== Dataset Overview ===\n")
cat("Dataset dimensions:", paste(dim(model_data), collapse = " x "), "\n")
cat("Columns:", ncol(model_data), "\n")
cat("Rows:", nrow(model_data), "\n\n")

# Check if ev_type variable exists (1-year survival classification target)
if ("outcome" %in% names(model_data)) {
  cat("outcome variable found âœ“\n")
  cat("outcome variable type:", class(model_data$outcome), "\n")
  cat("outcome summary:\n")
  print(table(model_data$outcome))
  cat("Event rate (outcome = 1):", round(mean(model_data$outcome, na.rm = TRUE) * 100, 2), "%\n")
} else {
  stop("outcome variable not found in the dataset!")
}

```

```{r echo=FALSE, warning=FALSE, message=FALSE, eval=TRUE}

# For classification models, we use `outcome` as the 1-year survival classification target
# No survival analysis variables (ev_time, days_to_last_followup) are needed

# Verify the `outcome` variable is properly formatted
cat("=== Classification Data Overview ===\n")
cat("Total observations:", nrow(model_data), "\n")
cat("outcome variable summary:\n")
print(table(model_data$outcome))
cat("Event rate (outcome = 1):", round(mean(model_data$outcome, na.rm = TRUE) * 100, 2), "%\n")

# Check for any missing values in outcome
cat("Missing values in outcome:", sum(is.na(model_data$outcome)), "\n")

# Ensure outcome is numeric (0 or 1)
model_data <- model_data %>%
  mutate(outcome = as.numeric(outcome))

# Verify outcome is binary
if (!all(model_data$outcome %in% c(0, 1, NA))) {
  warning("outcome variable contains non-binary values!")
  cat("Unique outcome values:", unique(model_data$outcome), "\n")
}

```

```{r classification-lagging-keywords, eval=TRUE}

# Unified classification modeling keywords (variables to exclude from all models)

classification_lagging_keywords <- c(
  # Identifiers and outcomes
  #"ptid_e",
  "transplant_year", "primary_etiology",
  
  # Time variables (not needed for classification)
  "ev_", "days_to_last_followup",
  
  # Donor-specific variables
  "graft_loss", "int_graft_loss", "dtx_", "cc_", "isc_oth",
  "dcardiac", "dcon", "dpri", "dpricaus", "rec_", "papooth",
  "dneuro", "sdprathr", "int_dead", "listing_year", "cpathneg",
  "dcauseod",
  
  # Demographics (if not clinically relevant)
  "race", "sex", "drace_b", "rrace_a", "hisp", "lscntry",
  
  # Transplant-specific variables
  "dreject", "dsecaccsEmpty", "dmajbldEmpty", "pishltgr1R", 
  "drejectEmpty", "drejectHyperacute", "pishltgrEmpty",
  "pishltgr", "dmajbld", "dsecaccs", "dsecaccs_bin", 
  
  # Clinical variables to exclude
  "dx_cardiomyopathy", "deathspc", "dlist", "pmorexam", 
  "patsupp", "concod", "pcadrem", "pcadrec", "pathero", 
  "pdiffib", "dmalcanc", "alt_tx", "age_death", "pacuref",
  "cpbypass",
  
  # Additional variables
  "lsvcma"
)


```

### Cohort-Specific Modeling Pipeline

#### CHD Cohort Analysis

```{r echo=FALSE, warning=FALSE, message=FALSE, eval=TRUE}

chd_data <- model_data %>% filter(primary_etiology == "Congenital HD")

# CHD Cohort summary
cat("CHD Cohort Size:", nrow(chd_data), "patients\n")
cat("outcome Distribution:\n")
print(table(chd_data$outcome))
cat("Event Rate (outcome = 1):", round(mean(chd_data$outcome, na.rm = TRUE) * 100, 2), "%\n")

# CHD Cohort descriptive statistics
chd_summary <- chd_data %>%
  select(where(is.numeric)) %>%
  summarise(across(everything(), list(
    mean = ~ round(mean(.x, na.rm = TRUE), 2),
    median = ~ round(median(.x, na.rm = TRUE), 2),
    sd = ~ round(sd(.x, na.rm = TRUE), 2)
  ))) %>%
  pivot_longer(everything(), names_to = "stat", values_to = "value") %>%
  separate(stat, into = c("variable", "statistic"), sep = "_(?=[^_]*$)") %>%
  pivot_wider(names_from = statistic, values_from = value)

# Display CHD summary table
datatable(
  chd_summary,
  rownames = FALSE,
  options = list(
    pageLength = 10,
    columnDefs = list(
      list(className = 'dt-left', targets = "_all")
    )
  )
)

```

```{r, eval=FALSE}

# Create unified train/test split for CHD cohort
chd_split <- create_unified_train_test_split(chd_data, "CHD", seed = 1997)

# Extract split info
chd_train_indices <- chd_split$split_info$train_indices
chd_test_indices <- chd_split$split_info$test_indices
chd_train_data <- chd_split$train_data
chd_test_data <- chd_split$test_data

# Verify the data split
cat("\n=== CHD Cohort Data Split ===\n")
cat("CHD Training set size:", nrow(chd_train_data), "\n")
cat("CHD Test set size:", nrow(chd_test_data), "\n")
cat("CHD Event rate (outcome = 1) in training:", round(mean(chd_train_data$outcome, na.rm = TRUE) * 100, 2), "%\n")
cat("CHD Event rate (outcome = 1) in test:", round(mean(chd_test_data$outcome, na.rm = TRUE) * 100, 2), "%\n")

```

##### CatBoost Classification Model (train in Python; data prepared in R)

```{r chd-catboost-model-df, echo=FALSE, warning=FALSE, message=FALSE, eval=TRUE}

# Prepare data for CatBoost classification
chd_catboost_df <- chd_data %>%
  # Remove lagging keywords and variables starting with "sd"
  select(
    !(matches(paste(classification_lagging_keywords, collapse = "|")) | starts_with("sd"))
  ) %>%
  # Handle infinite values by converting them to NA
  mutate(across(where(is.numeric), ~if_else(is.infinite(.), NA_real_, .))) %>%
  # Remove any columns that are entirely empty
  select(-where(~all(is.na(.)))) %>%
  # Remove identifier columns
  select(-ptid_e) %>%
  # Preserve categorical features as factors for Python CatBoost
  mutate(across(where(is.character), as.factor))

# Remove constant columns
constant_cols <- names(chd_catboost_df)[sapply(chd_catboost_df, function(x) {
  length(unique(na.omit(x))) == 1
})]
if(length(constant_cols) > 0) {
  chd_catboost_df <- chd_catboost_df %>% select(-all_of(constant_cols))
}

# Impute any remaining missing values
chd_catboost_df <- chd_catboost_df %>%
  mutate(across(everything(), ~if_else(is.na(.), median(., na.rm = TRUE), .)))

cat("CHD Classification CatBoost - Final data dimensions:", paste(dim(chd_catboost_df), collapse = " x "), "\n")

```

```{r chd-catboost-data-prep}

# Split the data using the existing train/test indices
chd_catboost_train <- chd_catboost_df[chd_train_indices, ]
chd_catboost_test  <- chd_catboost_df[chd_test_indices, ]

# Prepare training features and labels
chd_catboost_y_train <- chd_catboost_train$outcome
chd_catboost_x_train <- chd_catboost_train %>% select(-outcome)

# Prepare test features and labels
chd_catboost_y_test <- chd_catboost_test$outcome
chd_catboost_x_test <- chd_catboost_test %>% select(-outcome)

# Verify the data preparation
cat("CHD CatBoost Classification - Training set size:", nrow(chd_catboost_x_train), "\n")
cat("CHD CatBoost Classification - Test set size:", nrow(chd_catboost_x_test), "\n")
cat("CHD CatBoost Classification - Training features:", ncol(chd_catboost_x_train), "\n")

```


```{python}

# Train CHD CatBoost
import os
import pandas as pd
from catboost import CatBoostClassifier, Pool

chd_rf_train = r.chd_catboost_train
chd_rf_test  = r.chd_catboost_test

Xtr = chd_rf_train.drop(columns=['outcome'])
ytr = chd_rf_train['outcome']
Xte = chd_rf_test.drop(columns=['outcome'])
yte = chd_rf_test['outcome']

rf_model = CatBoostClassifier(
    iterations=500,
    depth=8,
    learning_rate=1.0,
    bootstrap_type='Bernoulli',
    subsample=0.8,
    sampling_frequency='PerTree',
    rsm=0.5,
    loss_function='Logloss',
    eval_metric='AUC',
    random_strength=1.0,
    l2_leaf_reg=3.0,
    random_seed=1997,
    verbose=100,
    use_best_model=False
)
# Ensure categorical handling
cat_cols = [c for c in Xtr.columns if str(Xtr[c].dtype) in ('object', 'category')]
for c in cat_cols:
    Xtr[c] = Xtr[c].astype('category')
    Xte[c] = Xte[c].astype('category')
train_pool = Pool(Xtr, ytr, cat_features=cat_cols)
test_pool  = Pool(Xte, yte, cat_features=cat_cols)
rf_model.fit(train_pool, eval_set=test_pool)

rf_model.save_model('chd_rf_model.json', format='json')
pd.concat([Xte.reset_index(drop=True), pd.Series(yte.values, name='outcome')], axis=1).to_csv('chd_rf_test.csv', index=False)
print('CHD CatBoost RF (Python) saved to chd_rf_model.json and chd_rf_test.csv')

```


```{python}

# Train CHD CatBoost model in Python and save JSON
import os
import pandas as pd
from catboost import CatBoostClassifier, Pool

# Access R-prepared dataframes via reticulate
chd_x_train = r.chd_catboost_x_train
chd_y_train = r.chd_catboost_y_train
chd_x_test  = r.chd_catboost_x_test
chd_y_test  = r.chd_catboost_y_test

model = CatBoostClassifier(
    loss_function='Logloss',
    eval_metric='Logloss',
    iterations=2000,
    depth=4,
    random_seed=1997,
    verbose=500
)
# Ensure categorical handling
cat_cols = [c for c in chd_x_train.columns if str(chd_x_train[c].dtype) in ('object', 'category')]
for c in cat_cols:
    chd_x_train[c] = chd_x_train[c].astype('category')
    chd_x_test[c]  = chd_x_test[c].astype('category')
train_pool = Pool(chd_x_train, chd_y_train, cat_features=cat_cols)
test_pool  = Pool(chd_x_test, chd_y_test, cat_features=cat_cols)
model.fit(train_pool, eval_set=test_pool)

model.save_model('chd_catboost_model.json', format='json')
pd.concat([chd_x_test.reset_index(drop=True), pd.Series(chd_y_test.values, name='outcome')], axis=1).to_csv('chd_catboost_test.csv', index=False)
print('CHD CatBoost (Python) saved to chd_catboost_model.json and chd_catboost_test.csv')
```

##### CatBoost Random Forest Classification Model

```{r chd-randomforest-fit-model, warning=FALSE, message=FALSE, echo=FALSE, eval=FALSE}

# Prepare data for CatBoost Random Forest classification
chd_rf_data <- chd_data %>%
  # Remove lagging keywords and variables starting with "sd"
  select(
    !(matches(paste(classification_lagging_keywords, collapse = "|")) | starts_with("sd"))
  ) %>%
  # Handle infinite values by converting them to NA
  mutate(across(where(is.numeric), ~if_else(is.infinite(.), NA_real_, .))) %>%
  # Remove any columns that are entirely empty
  select(-where(~all(is.na(.)))) %>%
  # Remove identifier columns
  select(-ptid_e) %>%
  # Ensure all categorical predictors are factors for CatBoost
  mutate(across(where(is.character), as.factor)) 

# Remove constant columns
constant_cols <- names(chd_rf_data)[sapply(chd_rf_data, function(x) {
  length(unique(na.omit(x))) == 1
})]
if(length(constant_cols) > 0) {
  chd_rf_data <- chd_rf_data %>% select(-all_of(constant_cols))
}


# Split data using existing train/test indices
chd_rf_train <- chd_rf_data[chd_train_indices, ]
chd_rf_test  <- chd_rf_data[chd_test_indices, ]

```

#### Myocarditis/Cardiomyopathy Cohort Analysis

```{r echo=FALSE, warning=FALSE, message=FALSE, eval=TRUE}

mc_data <- model_data %>% filter(primary_etiology %in% c("Cardiomyopathy", "Myocarditis"))


# Myo/Cardio Cohort summary
cat("Myocarditis/Cardiomyopathy Cohort Size:", nrow(mc_data), "patients\n")
cat("outcome Distribution:\n")
print(table(mc_data$outcome))
cat("Event Rate (outcome = 1):", round(mean(mc_data$outcome, na.rm = TRUE) * 100, 2), "%\n")

# Myo/Cardio Cohort descriptive statistics
mc_summary <- mc_data %>%
  select(where(is.numeric)) %>%
  summarise(across(everything(), list(
    mean = ~ round(mean(.x, na.rm = TRUE), 2),
    median = ~ round(median(.x, na.rm = TRUE), 2),
    sd = ~ round(sd(.x, na.rm = TRUE), 2)
  ))) %>%
  pivot_longer(everything(), names_to = "stat", values_to = "value") %>%
  separate(stat, into = c("variable", "statistic"), sep = "_(?=[^_]*$)") %>%
  pivot_wider(names_from = statistic, values_from = value)

# Display Myo/Cardio summary table
datatable(
  mc_summary,
  rownames = FALSE,
  options = list(
    pageLength = 10,
    columnDefs = list(
      list(className = 'dt-left', targets = "_all")
    )
  )
)

```

```{r}

# Create unified train/test split for Myo/Cardio cohort
mc_split <- create_unified_train_test_split(mc_data, "Myo/Cardio", seed = 1997)

# Extract split info
mc_train_indices <- mc_split$split_info$train_indices
mc_test_indices  <- mc_split$split_info$test_indices
mc_train_data    <- mc_split$train_data
mc_test_data     <- mc_split$test_data

```

##### CatBoost Classification Model

```{r myo-catboost-model-df, echo=FALSE, warning=FALSE, message=FALSE, eval=FALSE}

# Prepare data for CatBoost classification
mc_catboost_df <- mc_data %>%
  # Remove lagging keywords and variables starting with "sd"
  select(
    !(matches(paste(classification_lagging_keywords, collapse = "|")) | starts_with("sd"))
  ) %>%
  # Handle infinite values by converting them to NA
  mutate(across(where(is.numeric), ~if_else(is.infinite(.), NA_real_, .))) %>%
  # Remove any columns that are entirely empty
  select(-where(~all(is.na(.)))) %>%
  # Remove identifier columns
  select(-ptid_e) %>%
  # Preserve categorical features as factors for Python CatBoost
  mutate(across(where(is.character), as.factor))

# Remove constant columns
constant_cols <- names(mc_catboost_df)[sapply(mc_catboost_df, function(x) {
  length(unique(na.omit(x))) == 1
})]
if(length(constant_cols) > 0) {
  mc_catboost_df <- mc_catboost_df %>% select(-all_of(constant_cols))
}

# Impute any remaining missing values
mc_catboost_df <- mc_catboost_df %>%
  mutate(across(everything(), ~if_else(is.na(.), median(., na.rm = TRUE), .)))

cat("Myo/Cardio Classification CatBoost - Final data dimensions:", paste(dim(mc_catboost_df), collapse = " x "), "\n")

```

```{r myo-catboost-data-prep, eval=FALSE}

# Split the data using the existing train/test indices
mc_catboost_train <- mc_catboost_df[mc_train_indices, ]
mc_catboost_test  <- mc_catboost_df[mc_test_indices, ]

# Prepare training features and labels
mc_catboost_y_train <- mc_catboost_train$outcome
mc_catboost_x_train <- mc_catboost_train %>% select(-outcome)

# Prepare test features and labels
mc_catboost_y_test <- mc_catboost_test$outcome
mc_catboost_x_test <- mc_catboost_test %>% select(-outcome)

# Verify the data preparation
cat("Myo/Cardio CatBoost Classification - Training set size:", nrow(mc_catboost_x_train), "\n")
cat("Myo/Cardio CatBoost Classification - Test set size:", nrow(mc_catboost_x_test), "\n")
cat("Myo/Cardio CatBoost Classification - Training features:", ncol(mc_catboost_x_train), "\n")

```

```{python}

# (disabled) Train Myo/Cardio CatBoost model in Python and save JSON
import os
import pandas as pd
from catboost import CatBoostClassifier, Pool

mc_x_train = r.mc_catboost_x_train
mc_y_train = r.mc_catboost_y_train
mc_x_test  = r.mc_catboost_x_test
mc_y_test  = r.mc_catboost_y_test

model = CatBoostClassifier(
    loss_function='Logloss',
    eval_metric='Logloss',
    iterations=2000,
    depth=4,
    random_seed=1997,
    verbose=500
)
# Ensure categorical handling
cat_cols = [c for c in mc_x_train.columns if str(mc_x_train[c].dtype) in ('object', 'category')]
for c in cat_cols:
    mc_x_train[c] = mc_x_train[c].astype('category')
    mc_x_test[c]  = mc_x_test[c].astype('category')
train_pool = Pool(mc_x_train, mc_y_train, cat_features=cat_cols)
test_pool  = Pool(mc_x_test, mc_y_test, cat_features=cat_cols)
model.fit(train_pool, eval_set=test_pool)

model.save_model('mc_catboost_model.json', format='json')
pd.concat([mc_x_test.reset_index(drop=True), pd.Series(mc_y_test.values, name='outcome')], axis=1).to_csv('mc_catboost_test.csv', index=False)
print('Myo/Cardio CatBoost (Python) saved to mc_catboost_model.json and mc_catboost_test.csv')

```

##### CatBoost Random Forest Classification Model

```{r myo-randomforest-fit-model, echo=FALSE, warning=FALSE, message=FALSE, eval=FALSE}

# Prepare data for CatBoost Random Forest classification
mc_rf_data <- mc_data %>%
  # Remove lagging keywords and variables starting with "sd"
  select(
    !(matches(paste(classification_lagging_keywords, collapse = "|")) | starts_with("sd"))
  ) %>%
  # Handle infinite values by converting them to NA
  mutate(across(where(is.numeric), ~if_else(is.infinite(.), NA_real_, .))) %>%
  # Remove any columns that are entirely empty
  select(-where(~all(is.na(.)))) %>%
  # Remove identifier columns
  select(-ptid_e) %>%
  # Ensure all categorical predictors are factors for CatBoost
  mutate(across(where(is.character), as.factor)) 

# Remove constant columns
constant_cols <- names(mc_rf_data)[sapply(mc_rf_data, function(x) {
  length(unique(na.omit(x))) == 1
})]
if(length(constant_cols) > 0) {
  mc_rf_data <- mc_rf_data %>% select(-all_of(constant_cols))
}


# Split data using existing train/test indices
mc_rf_train <- mc_rf_data[mc_train_indices, ]
mc_rf_test  <- mc_rf_data[mc_test_indices, ]


```

```{python}

# (disabled) Train Myo/Cardio CatBoost RF-like model in Python and save JSON
import os
import pandas as pd
from catboost import CatBoostClassifier, Pool

mc_rf_train = r.mc_rf_train
mc_rf_test  = r.mc_rf_test

Xtr = mc_rf_train.drop(columns=['outcome'])
ytr = mc_rf_train['outcome']
Xte = mc_rf_test.drop(columns=['outcome'])
yte = mc_rf_test['outcome']

rf_model = CatBoostClassifier(
    iterations=500,
    depth=8,
    learning_rate=1.0,
    bootstrap_type='Bernoulli',
    subsample=0.8,
    sampling_frequency='PerTree',
    rsm=0.5,
    loss_function='Logloss',
    eval_metric='AUC',
    random_strength=1.0,
    l2_leaf_reg=3.0,
    random_seed=1997,
    verbose=100,
    use_best_model=False
)
# Ensure categorical handling
cat_cols = [c for c in Xtr.columns if str(Xtr[c].dtype) in ('object', 'category')]
for c in cat_cols:
    Xtr[c] = Xtr[c].astype('category')
    Xte[c] = Xte[c].astype('category')
train_pool = Pool(Xtr, ytr, cat_features=cat_cols)
test_pool  = Pool(Xte, yte, cat_features=cat_cols)
rf_model.fit(train_pool, eval_set=test_pool)

rf_model.save_model('mc_rf_model.json', format='json')
pd.concat([Xte.reset_index(drop=True), pd.Series(yte.values, name='outcome')], axis=1).to_csv('mc_rf_test.csv', index=False)
print('Myo/Cardio CatBoost RF (Python) saved to mc_rf_model.json and mc_rf_test.csv')

```

### FFA single-model smoke test

```{python}
#| echo: true
#| message: false
#| warning: false

import os
from catboost import CatBoostClassifier
from ffa_analysis.catboost_axp_explainer import PathConfig, analyze_model, AnalysisConfig

base_dir = '.'
test_model_json = os.path.join(base_dir, 'chd_catboost_model.json')
test_data_csv = os.path.join(base_dir, 'chd_catboost_test.csv')
test_output_dir = os.path.join(base_dir, 'ffa_outputs', '_smoketest', 'chd')

if os.path.exists(test_model_json) and os.path.exists(test_data_csv):
    os.makedirs(test_output_dir, exist_ok=True)

    path_config = PathConfig(
        model_path=test_model_json,
        data_dir=base_dir,
        output_dir=test_output_dir,
        age_band='all'
    )
    # Point test data path to the saved CSV
    path_config.test_data_path = test_data_csv

    model = CatBoostClassifier()
    model.load_model(test_model_json)

    analysis_cfg = AnalysisConfig(top_k=10, n_permutations=50)
    res = analyze_model(path_config, model, analysis_cfg)
    print('Single-model FFA complete. Outputs in:', test_output_dir)
else:
    print('Single-model FFA skipped: files not found.')
```

### Build Formal Feature Analysis (FFA) using saved CatBoost JSON

```{python}
#| echo: true
#| message: false
#| warning: false

import os
from catboost import CatBoostClassifier
from ffa_analysis.catboost_axp_explainer import PathConfig, analyze_model, AnalysisConfig

base_dir = '.'
cohorts = [
    {
        'name': 'CHD',
        'model_json': os.path.join(base_dir, 'chd_catboost_model.json'),
        'test_data': os.path.join(base_dir, 'chd_catboost_test.csv'),
        'output_dir': os.path.join(base_dir, 'ffa_outputs', 'chd')
    },
    {
        'name': 'MyoCardio',
        'model_json': os.path.join(base_dir, 'mc_catboost_model.json'),
        'test_data': os.path.join(base_dir, 'mc_catboost_test.csv'),
        'output_dir': os.path.join(base_dir, 'ffa_outputs', 'myo_cardio')
    },
    {
        'name': 'CHD_RF',
        'model_json': os.path.join(base_dir, 'chd_rf_model.json'),
        'test_data': os.path.join(base_dir, 'chd_rf_test.csv'),
        'output_dir': os.path.join(base_dir, 'ffa_outputs', 'chd_rf')
    },
    {
        'name': 'MyoCardio_RF',
        'model_json': os.path.join(base_dir, 'mc_rf_model.json'),
        'test_data': os.path.join(base_dir, 'mc_rf_test.csv'),
        'output_dir': os.path.join(base_dir, 'ffa_outputs', 'myo_cardio_rf')
    }
]

ffa_results = {}

for cohort in cohorts:
    if not (os.path.exists(cohort['model_json']) and os.path.exists(cohort['test_data'])):
        print(f"Skipping {cohort['name']} - required files missing")
        continue

    os.makedirs(cohort['output_dir'], exist_ok=True)

    path_config = PathConfig(
        model_path=cohort['model_json'],
        data_dir=base_dir,
        output_dir=cohort['output_dir'],
        age_band='all'
    )
    # Override the property for convenience to point at CSV
    path_config.test_data_path = cohort['test_data']

    model = CatBoostClassifier()
    model.load_model(cohort['model_json'])

    analysis_cfg = AnalysisConfig(top_k=15, n_permutations=200)
    try:
        res = analyze_model(path_config, model, analysis_cfg)
        ffa_results[cohort['name']] = res
        print(f"FFA complete for {cohort['name']}")
    except Exception as e:
        print(f"FFA failed for {cohort['name']}: {e}")

sorted(list(ffa_results.keys()))
```

